<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blue Archive Puzzle - 2D Centered Edition</title>
    <style>
        body {
            margin: 0; padding: 0;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh; background-color: #f0f4f8;
            font-family: 'Noto Sans KR', sans-serif; overflow: hidden;
        }
        #ui-layer {
            position: absolute; top: 20px; width: 92%; max-width: 1000px;
            display: flex; justify-content: space-between; pointer-events: none; z-index: 10;
        }
        .status-panel {
            background: rgba(255, 255, 255, 0.95); padding: 15px 25px;
            border-radius: 12px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border-left: 6px solid #2196f3; pointer-events: auto;
        }
        .controls { position: absolute; bottom: 30px; z-index: 10; }
        button {
            padding: 12px 35px; font-size: 16px; font-weight: bold;
            color: white; background-color: #2196f3; border: none;
            border-radius: 8px; cursor: pointer; transition: all 0.2s;
            box-shadow: 0 4px 0 #1976d2;
        }
        button:hover { background-color: #1e88e5; transform: translateY(-2px); }
        button:active { transform: translateY(2px); box-shadow: 0 0 0; }
        
        #game-canvas { background-color: #e1f5fe; border-radius: 20px; cursor: pointer; border: 2px solid #b3e5fc; }

        #warp-modal {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: white; padding: 25px 40px; border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2); border: 2px solid #2196f3;
            text-align: center; display: none; z-index: 200;
        }
        .modal-btns { margin-top: 20px; display: flex; gap: 15px; justify-content: center; }
        .btn-confirm { background-color: #2196f3; }
        .btn-cancel { background-color: #b0bec5; box-shadow: 0 4px 0 #78909c; }

        .message-box {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(33, 33, 33, 0.95); color: white; padding: 30px 60px;
            border-radius: 10px; font-size: 24px; display: none; z-index: 100;
            text-align: center; border: 2px solid #4fc3f7; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="status-panel">
            <div id="turn-display" style="font-weight: bold; color: #1565c0; font-size: 18px;">TURN 1 / 5</div>
            <div id="unit-display" style="font-size: 14px; margin-top: 5px; color: #555;">ì¡°ì‘ ìœ ë‹›: ì‹œë¡œì½”</div>
        </div>
        <div class="status-panel" style="text-align: right;">
            <div style="font-weight: bold; color: #d32f2f; font-size: 18px;">2D ì‘ì „ êµ¬ì—­</div>
            <div style="font-size: 13px; color: #777;">ë³´ìŠ¤ AI ê°œì„  ë²„ì „</div>
        </div>
    </div>

    <div id="warp-modal">
        <div style="font-weight: bold; font-size: 18px; color: #333;">ë°œíŒ ì´ë™ì„ í•˜ì‹œê² ìŠµë‹ˆê¹Œ?</div>
        <div style="font-size: 14px; color: #666; margin-top: 8px;">ì´ë™ ì‹œ ì´ë²ˆ í„´ì˜ í–‰ë™ì´ ì™„ë£Œë©ë‹ˆë‹¤.</div>
        <div class="modal-btns">
            <button class="btn-confirm" onclick="confirmWarp()">ì˜ˆ</button>
            <button class="btn-cancel" onclick="closeWarpModal()">ì•„ë‹ˆì˜¤</button>
        </div>
    </div>

    <div class="message-box" id="message-box"></div>
    <canvas id="game-canvas"></canvas>

    <div class="controls">
        <button onclick="endTurn()">í„´ ì¢…ë£Œ</button>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const msgBox = document.getElementById('message-box');
        const warpModal = document.getElementById('warp-modal');

        const hexSize = 50; 
        let turn = 1;
        let isMoving = false;
        let pendingWarp = null; 

        const TILE_STYLES = {
            NORMAL: { bg: '#ffffff', line: '#bbdefb' },
            START: { bg: '#e3f2fd', line: '#2196f3' },
            WARP: { bg: '#fffde7', line: '#fbc02d' },
            BOSS: { bg: '#ffebee', line: '#f44336' }
        };

        const tiles = [
            { q: 0, r: 0, type: 'START' }, 
            { q: 1, r: 0, type: 'WARP', arrow: 'UD', target: { q: 3, r: 2 } }, 
            { q: 0, r: 1, type: 'NORMAL' }, 
            { q: -1, r: 2, type: 'START' }, 
            { q: 0, r: 2, type: 'WARP', arrow: 'U', target: { q: 4, r: 0 } },
            { q: 4, r: 0, type: 'WARP', arrow: 'U', target: { q: 0, r: 2 } },
            { q: 5, r: 0, type: 'NORMAL' }, 
            { q: 6, r: 0, type: 'NORMAL' }, 
            { q: 6, r: 1, type: 'NORMAL' }, 
            { q: 5, r: 2, type: 'BOSS' },
            { q: 3, r: 2, type: 'WARP', arrow: 'D', target: { q: 1, r: 0 } },
            { q: 3, r: 3, type: 'NORMAL' }
        ];

        // ì  ìœ ë‹› ì´ˆê¸° ìœ„ì¹˜ë¥¼ í¬í•¨í•œ ë°ì´í„°
        let enemies = [
            { q: 5, r: 0, rank: 3, alive: true, aggressive: false, initialQ: 5, initialR: 0 },
            { q: 6, r: 0, rank: 3, alive: true, aggressive: false, initialQ: 6, initialR: 0 },
            { q: 5, r: 2, isBoss: true, alive: true, aggressive: true, initialQ: 5, initialR: 2 }, 
            { q: 3, r: 3, rank: 1, alive: true, aggressive: true, initialQ: 3, initialR: 3 }    
        ];

        let players = [
            { id: 0, name: 'í˜¸ì‹œë…¸', color: '#ff80ab', q: 0, r: 0, hasMoved: false },
            { id: 1, name: 'ì‹œë¡œì½”', color: '#4fc3f7', q: -1, r: 2, hasMoved: false }
        ];
        let selectedIdx = 1;

        const mapCenter = { q: 2.5, r: 1.5 };

        function initCanvas() {
            canvas.width = Math.min(window.innerWidth * 0.95, 1000);
            canvas.height = 600;
            render();
        }

        function hexToPixel(q, r) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const x = hexSize * Math.sqrt(3) * ( (q - mapCenter.q) + (r - mapCenter.r)/2 ) + centerX;
            const y = hexSize * 3/2 * (r - mapCenter.r) + centerY;
            return { x, y };
        }

        function pixelToHex(x, y) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const px = x - centerX;
            const py = y - centerY;
            const q = (Math.sqrt(3)/3 * px - 1/3 * py) / hexSize + mapCenter.q;
            const r = (2/3 * py) / hexSize + mapCenter.r;
            return axialRound(q, r);
        }

        function axialRound(q, r) {
            let x = q, y = r, z = -q - r;
            let rx = Math.round(x), ry = Math.round(y), rz = Math.round(z);
            const x_diff = Math.abs(rx - x);
            const y_diff = Math.abs(ry - y);
            const z_diff = Math.abs(rz - z);
            if (x_diff > y_diff && x_diff > z_diff) rx = -ry - rz;
            else if (y_diff > z_diff) ry = -rx - rz;
            else rz = -rx - ry;
            return { q: rx, r: ry };
        }

        function drawHex(x, y, tile, isHighlight = false) {
            const style = TILE_STYLES[tile.type];
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i - Math.PI / 2;
                ctx.lineTo(x + hexSize * Math.cos(angle), y + hexSize * Math.sin(angle));
            }
            ctx.closePath();
            ctx.fillStyle = style.bg;
            ctx.fill();
            ctx.strokeStyle = style.line;
            ctx.lineWidth = isHighlight ? 5 : 2;
            ctx.stroke();

            ctx.textAlign = 'center';
            ctx.font = 'bold 10px Arial';
            if (tile.type === 'START') {
                ctx.fillStyle = style.line; ctx.fillText('START', x, y + 5);
            } else if (tile.type === 'BOSS') {
                ctx.fillStyle = style.line; ctx.fillText('BOSS', x, y + 5);
            } else if (tile.type === 'WARP') {
                ctx.font = '16px Arial';
                ctx.fillStyle = '#fbc02d';
                if (tile.arrow === 'UD') ctx.fillText('â†‘â†“', x, y + 7);
                else if (tile.arrow === 'U') ctx.fillText('â†‘', x, y + 7);
                else if (tile.arrow === 'D') ctx.fillText('â†“', x, y + 7);
            }
        }

        function drawUnits() {
            enemies.filter(e => e.alive).forEach(enemy => {
                const { x, y } = hexToPixel(enemy.q, enemy.r);
                if (enemy.aggressive) {
                    ctx.fillStyle = '#f44336'; ctx.font = 'bold 18px Arial';
                    ctx.fillText('>>>', x + 40, y + 5);
                }
                ctx.beginPath(); ctx.arc(x, y - 5, 20, 0, Math.PI * 2);
                ctx.fillStyle = enemy.isBoss ? '#b71c1c' : '#37474f'; ctx.fill();
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
                
                ctx.fillStyle = '#f44336'; ctx.font = 'bold 9px Arial';
                ctx.fillText(enemy.isBoss ? 'BOSS' : 'RANK ' + enemy.rank, x, y + 30);
            });

            players.forEach((p, idx) => {
                const { x, y } = hexToPixel(p.q, p.r);
                if (selectedIdx === idx) {
                    ctx.beginPath(); ctx.arc(x, y - 5, 30, 0, Math.PI * 2);
                    ctx.strokeStyle = '#2196f3'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
                    ctx.stroke(); ctx.setLineDash([]);
                }
                ctx.beginPath(); ctx.arc(x, y - 5, 24, 0, Math.PI * 2);
                ctx.fillStyle = p.hasMoved ? '#cfd8dc' : p.color; ctx.fill();
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
                ctx.fillStyle = '#333'; ctx.font = 'bold 11px Arial';
                ctx.fillText(p.name, x, y + 35);
            });
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const currentP = players[selectedIdx];
            tiles.forEach(tile => {
                const { x, y } = hexToPixel(tile.q, tile.r);
                const canMove = getDistance(currentP, tile) === 1 && !currentP.hasMoved;
                drawHex(x, y, tile, canMove);
            });
            drawUnits();
            updateUI();
            requestAnimationFrame(render);
        }

        function updateUI() {
            const p = players[selectedIdx];
            document.getElementById('turn-display').innerText = `TURN ${turn} / 5`;
            document.getElementById('unit-display').innerText = `ì¡°ì‘ ìœ ë‹›: ${p.name} (${p.hasMoved ? 'ì™„ë£Œ' : 'ëŒ€ê¸°'})`;
        }

        function getDistance(a, b) {
            return (Math.abs(a.q - b.q) + Math.abs(a.q + a.r - b.q - b.r) + Math.abs(a.r - b.r)) / 2;
        }

        function showMessage(text, color = "white") {
            msgBox.innerText = text; msgBox.style.color = color;
            msgBox.style.display = 'block';
            setTimeout(() => msgBox.style.display = 'none', 1500);
        }

        function showWarpModal(player, tile) {
            pendingWarp = { player, tile };
            warpModal.style.display = 'block';
        }

        function closeWarpModal() {
            warpModal.style.display = 'none';
            pendingWarp = null;
        }

        function confirmWarp() {
            if (!pendingWarp) return;
            const { player, tile } = pendingWarp;
            setTimeout(() => {
                player.q = tile.target.q;
                player.r = tile.target.r;
                player.hasMoved = true; 
                closeWarpModal();
            }, 300);
        }

        canvas.addEventListener('mousedown', (e) => {
            if (isMoving || warpModal.style.display === 'block') return;
            const rect = canvas.getBoundingClientRect();
            const hex = pixelToHex(e.clientX - rect.left, e.clientY - rect.top);
            
            const pIdx = players.findIndex(p => p.q === hex.q && p.r === hex.r);
            if (pIdx !== -1) {
                if (selectedIdx === pIdx) {
                    const currentTile = tiles.find(t => t.q === hex.q && t.r === hex.r);
                    if (currentTile && currentTile.type === 'WARP' && !players[pIdx].hasMoved) {
                        showWarpModal(players[pIdx], currentTile);
                    }
                }
                selectedIdx = pIdx;
                return;
            }

            const p = players[selectedIdx];
            if (p.hasMoved) return;

            const target = tiles.find(t => t.q === hex.q && t.r === hex.r);
            if (target && getDistance(p, hex) === 1) {
                moveUnit(p, target);
            }
        });

        function moveUnit(p, tile) {
            isMoving = true;
            p.q = tile.q; p.r = tile.r;
            p.hasMoved = true;

            setTimeout(() => {
                const enemy = enemies.find(e => e.q === tile.q && e.r === tile.r && e.alive);
                if (enemy) {
                    enemy.alive = false; 
                    checkTile(p, tile);
                } else {
                    checkTile(p, tile);
                }
            }, 200);
        }

        function checkTile(p, tile) {
            if (tile.type === 'WARP') {
                showWarpModal(p, tile);
                isMoving = false;
            } else if (tile.type === 'BOSS') {
                showMessage("ğŸ‰ MISSION CLEAR! ğŸ‰", "#4caf50");
                isMoving = false;
            } else {
                isMoving = false;
            }
        }

        async function endTurn() {
            if (isMoving || warpModal.style.display === 'block') return;
            isMoving = true;
            
            const aggrEnemies = enemies.filter(e => e.alive && e.aggressive);
            
            for (let enemy of aggrEnemies) {
                let targetP = players[0];
                let minDist = getDistance(enemy, players[0]);
                players.forEach(p => { 
                    let d = getDistance(enemy, p);
                    if (d < minDist) { targetP = p; minDist = d; } 
                });

                const dirs = [{q:1,r:0}, {q:0,r:1}, {q:-1,r:1}, {q:-1,r:0}, {q:0,r:-1}, {q:1,r:-1}];
                let bestMove = {q: enemy.q, r: enemy.r};
                let currentDist = minDist;

                for (let d of dirs) {
                    const nQ = enemy.q + d.q;
                    const nR = enemy.r + d.r;
                    if (tiles.find(t => t.q === nQ && t.r === nR)) {
                        const dToP = getDistance({q:nQ, r:nR}, targetP);
                        // ê±°ë¦¬ê°€ ë” ê°€ê¹Œì›Œì§€ê±°ë‚˜, í˜¹ì€ ìµœì†Œí•œ ë” ë©€ì–´ì§€ì§€ ì•ŠëŠ” ê²½ìš°ë¼ë„ ì´ë™ì„ ì‹œë„í•˜ì—¬ ë©ˆì¶¤ ë°©ì§€
                        if (dToP <= currentDist) {
                            currentDist = dToP;
                            bestMove = {q: nQ, r: nR};
                        }
                    }
                }

                enemy.q = bestMove.q;
                enemy.r = bestMove.r;
                
                // ì´ë™ í›„ ì¡°ìš° ì²´í¬: ì ì´ ì•„êµ° ì¹¸ìœ¼ë¡œ ë“¤ì–´ì™”ì„ ë•Œ ì¦‰ì‹œ ê²©íŒŒ ì²˜ë¦¬
                players.forEach(p => {
                    if (enemy.q === p.q && enemy.r === p.r) {
                        enemy.alive = false;
                    }
                });
            }

            setTimeout(() => {
                turn++;
                players.forEach(p => p.hasMoved = false);
                isMoving = false;
                if (turn > 5) { showMessage("ì‘ì „ ì‹¤íŒ¨", "#f44336"); reset(); }
            }, 500);
        }

        function reset() {
            turn = 1; 
            players[0].q = 0; players[0].r = 0; 
            players[1].q = -1; players[1].r = 2;
            players.forEach(p => p.hasMoved = false);
            enemies.forEach(e => { 
                e.alive = true; 
                e.q = e.initialQ; // ê° ì ì˜ ê³ ìœ  ì´ˆê¸° ìœ„ì¹˜ë¡œ ë³µêµ¬
                e.r = e.initialR;
            });
            closeWarpModal();
        }

        window.addEventListener('resize', initCanvas);
        window.onload = initCanvas;
    </script>
</body>
</html>
