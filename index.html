<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blue Archive Puzzle - Advanced AI Tactics</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');

        body {
            margin: 0; padding: 0;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh; background-color: #f0f4f8;
            font-family: 'Noto Sans KR', sans-serif; overflow: hidden;
        }
        #ui-layer {
            position: absolute; top: 20px; width: 92%; max-width: 1000px;
            display: flex; justify-content: space-between; pointer-events: none; z-index: 10;
        }
        .status-panel {
            background: rgba(255, 255, 255, 0.95); padding: 15px 25px;
            border-radius: 12px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border-left: 6px solid #2196f3; pointer-events: auto;
        }
        .controls { 
            position: absolute; bottom: 30px; z-index: 10; 
            display: flex; gap: 15px;
        }
        button {
            padding: 12px 30px; font-size: 16px; font-weight: bold;
            color: white; background-color: #2196f3; border: none;
            border-radius: 8px; cursor: pointer; transition: all 0.2s;
            box-shadow: 0 4px 0 #1976d2;
        }
        button:hover { background-color: #1e88e5; transform: translateY(-2px); }
        button:active { transform: translateY(2px); box-shadow: 0 0 0; }
        
        .btn-restart { background-color: #ff9800; box-shadow: 0 4px 0 #e68a00; }

        #game-canvas { background-color: #e1f5fe; border-radius: 20px; cursor: pointer; border: 2px solid #b3e5fc; }

        .modal {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: white; padding: 25px 40px; border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3); border: 2px solid #2196f3;
            text-align: center; display: none; z-index: 200;
        }
        .modal-btns { margin-top: 20px; display: flex; gap: 15px; justify-content: center; }
        .btn-confirm { background-color: #2196f3; }
        .btn-cancel { background-color: #b0bec5; box-shadow: 0 4px 0 #78909c; }

        .message-box {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(33, 33, 33, 0.95); color: white; padding: 30px 60px;
            border-radius: 10px; font-size: 32px; font-weight: bold; display: none; z-index: 100;
            text-align: center; border: 2px solid #4fc3f7; pointer-events: none;
            box-shadow: 0 0 20px rgba(79, 195, 247, 0.5);
        }

        .mission-goals { margin-top: 8px; font-size: 13px; text-align: left; }
        .goal-item { display: flex; align-items: center; gap: 8px; margin-bottom: 2px; }
        .goal-star { color: #ccc; font-size: 16px; }
        .goal-star.active { color: #fbc02d; text-shadow: 0 0 5px rgba(251, 192, 45, 0.5); }

        .auto-turn-wrapper { margin-top: 8px; border-top: 1px solid #eee; padding-top: 8px; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="status-panel">
            <div id="turn-display" style="font-weight: bold; color: #1565c0; font-size: 18px;">TURN 1 / 5</div>
            <div id="unit-display" style="font-size: 14px; margin-top: 4px; color: #555;">ì¡°ì‘ ìœ ë‹›: ì‹œë¡œì½”</div>
            
            <div class="mission-goals" id="mission-list">
                <div class="goal-item"><span class="goal-star" id="star-kill">â˜…</span> ì êµ° 3ëª… ì²˜ì¹˜ (<span id="count-kill">0</span>/3)</div>
                <div class="goal-item"><span class="goal-star" id="star-turn">â˜…</span> 5í„´ ì´ë‚´ í´ë¦¬ì–´</div>
                <div class="goal-item"><span class="goal-star" id="star-boss">â˜…</span> ë³´ìŠ¤ ë¶€ëŒ€ ê²©íŒŒ</div>
            </div>

            <div class="auto-turn-wrapper">
                <label style="cursor:pointer; font-size:12px; color:#666; display: flex; align-items: center; gap: 5px;">
                    <input type="checkbox" id="auto-turn-checkbox"> ìë™ í„´ ì¢…ë£Œ
                </label>
            </div>
        </div>
        <div class="status-panel" style="text-align: right;">
            <div style="font-weight: bold; color: #d32f2f; font-size: 18px;">ì„ë¬´: BOSS ê²©íŒŒ</div>
            <div style="font-size: 12px; color: #777;">ì§€í˜• ë¶„ì„ ê¸°ë°˜ ìµœì í™” AI ì ìš©</div>
        </div>
    </div>

    <!-- ì›Œí”„ ëª¨ë‹¬ -->
    <div id="warp-modal" class="modal">
        <div style="font-weight: bold; font-size: 18px; color: #333;">ë°œíŒ ì´ë™ì„ í•˜ì‹œê² ìŠµë‹ˆê¹Œ?</div>
        <div style="font-size: 14px; color: #666; margin-top: 8px;">ì›Œí”„ëŠ” í–‰ë™ë ¥ì„ ì†Œëª¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.</div>
        <div class="modal-btns">
            <button class="btn-confirm" onclick="confirmWarp()">ì˜ˆ</button>
            <button class="btn-cancel" onclick="closeWarpModal()">ì•„ë‹ˆì˜¤</button>
        </div>
    </div>

    <!-- í„´ ì¢…ë£Œ í™•ì¸ ëª¨ë‹¬ -->
    <div id="end-turn-modal" class="modal">
        <div style="font-weight: bold; font-size: 18px; color: #333;">í„´ì„ ì¢…ë£Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?</div>
        <div style="font-size: 14px; color: #f44336; margin-top: 8px;">ì•„ì§ í–‰ë™í•˜ì§€ ì•Šì€ ë¶€ëŒ€ê°€ ìˆìŠµë‹ˆë‹¤.</div>
        <div class="modal-btns">
            <button class="btn-confirm" onclick="forceEndTurn()">ì¢…ë£Œ</button>
            <button class="btn-cancel" onclick="closeEndTurnModal()">ì·¨ì†Œ</button>
        </div>
    </div>

    <div class="message-box" id="message-box"></div>
    <canvas id="game-canvas"></canvas>

    <div class="controls">
        <button class="btn-restart" onclick="reset()">ì²˜ìŒë¶€í„° ë‹¤ì‹œí•˜ê¸°</button>
        <button onclick="handleEndTurnBtn()">í„´ ì¢…ë£Œ</button>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const msgBox = document.getElementById('message-box');
        const warpModal = document.getElementById('warp-modal');
        const endTurnModal = document.getElementById('end-turn-modal');
        const autoTurnCheckbox = document.getElementById('auto-turn-checkbox');

        const hexSize = 52; 
        let turn = 1;
        let isMoving = false;
        let pendingWarp = null; 
        let killCount = 0;
        let isBossDefeated = false;
        let activeAnimations = [];

        const TILE_STYLES = {
            NORMAL: { bg: '#ffffff', line: '#bbdefb' },
            START: { bg: '#e1f5fe', line: '#03a9f4' }, 
            WARP: { bg: '#ffc1e3', line: '#2196f3' }, 
            BOSS: { bg: '#ffebee', line: '#f44336' }
        };

        const tiles = [
            { q: 0, r: 0, type: 'START' }, 
            { q: 1, r: 0, type: 'WARP', portalNum: 1, arrow: 'UD', target: { q: 3, r: 2 } }, 
            { q: 0, r: 1, type: 'NORMAL' }, 
            { q: -1, r: 2, type: 'START' }, 
            { q: 0, r: 2, type: 'WARP', portalNum: 2, arrow: 'U', target: { q: 4, r: 0 } },
            { q: 4, r: 0, type: 'WARP', portalNum: 2, arrow: 'U', target: { q: 0, r: 2 } },
            { q: 5, r: 0, type: 'NORMAL' }, 
            { q: 6, r: 0, type: 'NORMAL' }, 
            { q: 6, r: 1, type: 'NORMAL' }, 
            { q: 5, r: 2, type: 'BOSS' },
            { q: 3, r: 2, type: 'WARP', portalNum: 1, arrow: 'D', target: { q: 1, r: 0 } },
            { q: 3, r: 3, type: 'NORMAL' }
        ];

        let enemies = [
            { q: 5, r: 0, alive: true, aggressive: false, initialQ: 5, initialR: 0 },
            { q: 6, r: 0, alive: true, aggressive: false, initialQ: 6, initialR: 0 },
            { q: 5, r: 2, isBoss: true, alive: true, aggressive: true, initialQ: 5, initialR: 2 }, 
            { q: 3, r: 3, alive: true, aggressive: true, initialQ: 3, initialR: 3 }    
        ];

        let players = [
            { id: 0, name: 'í˜¸ì‹œë…¸', color: '#ff80ab', haloColor: '#ff4081', q: 0, r: 0, hasMoved: false },
            { id: 1, name: 'ì‹œë¡œì½”', color: '#b3e5fc', haloColor: '#03a9f4', q: -1, r: 2, hasMoved: false }
        ];
        let selectedIdx = 1;

        const mapCenter = { q: 2.5, r: 1.5 };

        function initCanvas() {
            canvas.width = Math.min(window.innerWidth * 0.95, 1000);
            canvas.height = 650;
            render();
        }

        function hexToPixel(q, r) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const x = hexSize * Math.sqrt(3) * ( (q - mapCenter.q) + (r - mapCenter.r)/2 ) + centerX;
            const y = hexSize * 3/2 * (r - mapCenter.r) + centerY;
            return { x, y };
        }

        function pixelToHex(x, y) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const px = x - centerX;
            const py = y - centerY;
            const q = (Math.sqrt(3)/3 * px - 1/3 * py) / hexSize + mapCenter.q;
            const r = (2/3 * py) / hexSize + mapCenter.r;
            return axialRound(q, r);
        }

        function axialRound(q, r) {
            let x = q, y = r, z = -q - r;
            let rx = Math.round(x), ry = Math.round(y), rz = Math.round(z);
            const x_diff = Math.abs(rx - x);
            const y_diff = Math.abs(ry - y);
            const z_diff = Math.abs(rz - z);
            if (x_diff > y_diff && x_diff > z_diff) rx = -ry - rz;
            else if (y_diff > z_diff) ry = -rx - rz;
            else rz = -rx - ry;
            return { q: rx, r: ry };
        }

        function drawHex(x, y, tile, isHighlight = false) {
            const style = TILE_STYLES[tile.type];
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i - Math.PI / 2;
                ctx.lineTo(x + hexSize * Math.cos(angle), y + hexSize * Math.sin(angle));
            }
            ctx.closePath();
            
            ctx.fillStyle = style.bg;
            if (tile.type === 'START') {
                ctx.save(); ctx.shadowBlur = 15; ctx.shadowColor = "#03a9f4"; ctx.fill(); ctx.restore();
            } else ctx.fill();
            
            ctx.strokeStyle = style.line;
            ctx.lineWidth = (tile.type === 'START') ? 4 : 2;
            ctx.stroke();

            if (isHighlight) {
                const innerSize = hexSize * 0.4;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i - Math.PI / 2;
                    ctx.lineTo(x + innerSize * Math.cos(angle), y + innerSize * Math.sin(angle));
                }
                ctx.closePath();
                ctx.fillStyle = "#fff176";
                ctx.fill();
                ctx.strokeStyle = "#fbc02d";
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            ctx.textAlign = 'center';
            if (tile.type === 'START') {
                ctx.fillStyle = "#0277bd"; ctx.font = 'bold 11px Arial';
                ctx.fillText('START', x, y + 25);
            } else if (tile.type === 'BOSS') {
                ctx.fillStyle = "#c62828"; ctx.font = 'bold 11px Arial';
                ctx.fillText('BOSS', x, y + 25);
            } else if (tile.type === 'WARP') {
                ctx.fillStyle = '#1a237e'; ctx.font = 'bold 13px Arial';
                ctx.fillText(`${tile.portalNum}`, x, y - 10);
                ctx.font = '16px Arial';
                if (tile.arrow === 'UD') ctx.fillText('â†‘â†“', x, y + 14);
                else if (tile.arrow === 'U') ctx.fillText('â†‘', x, y + 14);
                else if (tile.arrow === 'D') ctx.fillText('â†“', x, y + 14);
            }
        }

        function drawUnits() {
            enemies.filter(e => e.alive).forEach(enemy => {
                const { x, y } = hexToPixel(enemy.q, enemy.r);
                if (enemy.aggressive) {
                    ctx.fillStyle = '#f44336'; ctx.font = 'bold 18px Arial';
                    ctx.fillText('>>>', x + 42, y + 5);
                }
                ctx.beginPath(); ctx.ellipse(x, y + 10, 18, 8, 0, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fill();

                ctx.beginPath(); ctx.arc(x, y - 5, 20, 0, Math.PI * 2);
                ctx.fillStyle = enemy.isBoss ? '#b71c1c' : '#37474f'; ctx.fill();
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
                
                ctx.fillStyle = '#fff'; ctx.font = 'bold 9px Arial';
                ctx.fillText(enemy.isBoss ? 'BOSS' : 'ENEMY', x, y + 2);
            });

            players.forEach((p, idx) => {
                const { x, y } = hexToPixel(p.q, p.r);
                const isSelected = (selectedIdx === idx);

                ctx.beginPath(); ctx.ellipse(x, y + 12, 22, 10, 0, 0, Math.PI * 2);
                ctx.fillStyle = isSelected ? '#2196f3' : 'rgba(0,0,0,0.2)';
                ctx.fill(); ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();

                ctx.beginPath(); ctx.moveTo(x - 12, y + 10); ctx.lineTo(x + 12, y + 10);
                ctx.lineTo(x + 8, y - 15); ctx.lineTo(x - 8, y - 15); ctx.closePath();
                ctx.fillStyle = p.hasMoved ? '#cfd8dc' : p.color;
                ctx.fill(); ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();

                ctx.beginPath(); ctx.arc(x, y - 18, 12, 0, Math.PI * 2);
                ctx.fill(); ctx.stroke();

                ctx.beginPath(); ctx.ellipse(x, y - 35, 14, 4, 0, 0, Math.PI * 2);
                ctx.strokeStyle = p.haloColor; ctx.lineWidth = 2; ctx.stroke();

                if (isSelected) {
                    ctx.beginPath(); ctx.arc(x, y, 38, 0, Math.PI * 2);
                    ctx.strokeStyle = '#2196f3'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
                    ctx.stroke(); ctx.setLineDash([]);
                }
                ctx.fillStyle = '#333'; ctx.font = 'bold 11px Arial';
                ctx.fillText(p.name, x, y + 35);
            });
        }

        function drawAnimations() {
            const now = Date.now();
            activeAnimations = activeAnimations.filter(anim => now - anim.startTime < anim.duration);

            activeAnimations.forEach(anim => {
                const { x, y } = hexToPixel(anim.q, anim.r);
                const jitterX = (Math.random() - 0.5) * 15;
                const jitterY = (Math.random() - 0.5) * 15;

                ctx.save();
                ctx.translate(x + jitterX, y + jitterY);
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 / 8) * i;
                    const r = 30 + Math.sin(now * 0.05 + i) * 5;
                    const px = Math.cos(angle) * r;
                    const py = Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(px, py); else ctx.quadraticCurveTo(0, 0, px, py);
                }
                ctx.fillStyle = "rgba(255, 255, 255, 0.85)";
                ctx.fill(); ctx.strokeStyle = "#ccc"; ctx.lineWidth = 2; ctx.stroke();
                
                ctx.beginPath(); ctx.moveTo(-20, -20); ctx.lineTo(20, 20); ctx.moveTo(20, -20); ctx.lineTo(-20, 20);
                ctx.strokeStyle = "#ff5252"; ctx.lineWidth = 3; ctx.stroke();
                ctx.restore();
            });
        }

        function addBattleAnimation(q, r) {
            activeAnimations.push({ q, r, startTime: Date.now(), duration: 800 });
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const currentP = players[selectedIdx];
            tiles.forEach(tile => {
                const { x, y } = hexToPixel(tile.q, tile.r);
                const canMove = getDistance(currentP, tile) === 1 && !currentP.hasMoved;
                drawHex(x, y, tile, canMove);
            });
            drawUnits();
            drawAnimations();
            updateMissionUI();
            requestAnimationFrame(render);
        }

        function updateMissionUI() {
            document.getElementById('turn-display').innerText = `TURN ${turn} / 5`;
            const p = players[selectedIdx];
            document.getElementById('unit-display').innerText = `ì¡°ì‘ ìœ ë‹›: ${p.name} (${p.hasMoved ? 'ì™„ë£Œ' : 'ëŒ€ê¸°'})`;
            document.getElementById('count-kill').innerText = killCount;
            
            if (killCount >= 3) document.getElementById('star-kill').classList.add('active');
            else document.getElementById('star-kill').classList.remove('active');
            if (turn <= 5 && isBossDefeated) document.getElementById('star-turn').classList.add('active');
            if (isBossDefeated) document.getElementById('star-boss').classList.add('active');
        }

        function getDistance(a, b) {
            return (Math.abs(a.q - b.q) + Math.abs(a.q + a.r - b.q - b.r) + Math.abs(a.r - b.r)) / 2;
        }

        /**
         * 1ë‹¨ê³„: ìœ ë‹› ë¬´ì‹œí•˜ê³  ì§€í˜•ì ìœ¼ë¡œ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸ (ì„¬ íŒë³„ìš©)
         * ë°˜í™˜ê°’: ê²½ë¡œ ë°°ì—´ ë˜ëŠ” null (ì—°ê²° ì•ˆ ë¨)
         */
        function getTopologyPath(start, target) {
            let queue = [[{q: start.q, r: start.r}]];
            let visited = new Set();
            visited.add(`${start.q},${start.r}`);

            while(queue.length > 0) {
                let path = queue.shift();
                let curr = path[path.length - 1];

                if(curr.q === target.q && curr.r === target.r) return path;

                const dirs = [{q:1,r:0}, {q:0,r:1}, {q:-1,r:1}, {q:-1,r:0}, {q:0,r:-1}, {q:1,r:-1}];
                for(let d of dirs) {
                    let nextQ = curr.q + d.q;
                    let nextR = curr.r + d.r;
                    let key = `${nextQ},${nextR}`;
                    
                    const tile = tiles.find(t => t.q === nextQ && t.r === nextR);
                    if(!visited.has(key) && tile) {
                        visited.add(key);
                        queue.push([...path, {q: nextQ, r: nextR}]);
                    }
                }
            }
            return null;
        }

        function showMessage(text, color = "white") {
            msgBox.innerText = text; msgBox.style.color = color;
            msgBox.style.display = 'block';
            setTimeout(() => msgBox.style.display = 'none', 1500);
        }

        function showWarpModal(player, tile) {
            pendingWarp = { player, tile };
            warpModal.style.display = 'block';
        }

        function closeWarpModal() {
            warpModal.style.display = 'none';
            pendingWarp = null;
            checkAutoTurnEnd();
        }

        function confirmWarp() {
            if (!pendingWarp) return;
            const { player, tile } = pendingWarp;
            setTimeout(() => {
                player.q = tile.target.q;
                player.r = tile.target.r;
                closeWarpModal();
            }, 300);
        }

        function handleEndTurnBtn() {
            const idleUnits = players.filter(p => !p.hasMoved);
            if (idleUnits.length > 0 && !isBossDefeated) endTurnModal.style.display = 'block';
            else endTurn();
        }

        function closeEndTurnModal() { endTurnModal.style.display = 'none'; }
        function forceEndTurn() { closeEndTurnModal(); endTurn(); }

        canvas.addEventListener('mousedown', (e) => {
            if (isMoving || warpModal.style.display === 'block' || endTurnModal.style.display === 'block' || isBossDefeated) return;
            const rect = canvas.getBoundingClientRect();
            const hex = pixelToHex(e.clientX - rect.left, e.clientY - rect.top);
            
            const pIdx = players.findIndex(p => p.q === hex.q && p.r === hex.r);
            if (pIdx !== -1) {
                if (selectedIdx === pIdx) {
                    const currentTile = tiles.find(t => t.q === hex.q && t.r === hex.r);
                    if (currentTile && currentTile.type === 'WARP') showWarpModal(players[pIdx], currentTile);
                }
                selectedIdx = pIdx;
                return;
            }

            const p = players[selectedIdx];
            if (p.hasMoved) return;

            const target = tiles.find(t => t.q === hex.q && t.r === hex.r);
            if (target && getDistance(p, hex) === 1) moveUnit(p, target);
        });

        function moveUnit(p, tile) {
            isMoving = true;
            p.q = tile.q; p.r = tile.r;
            p.hasMoved = true;

            setTimeout(() => {
                const enemy = enemies.find(e => e.q === tile.q && e.r === tile.r && e.alive);
                if (enemy) {
                    addBattleAnimation(tile.q, tile.r);
                    enemy.alive = false; killCount++;
                    if (enemy.isBoss) { isBossDefeated = true; showGameResult(); }
                }
                checkTileAction(p, tile);
                if (warpModal.style.display !== 'block') checkAutoTurnEnd();
            }, 200);
        }

        function checkTileAction(p, tile) {
            if (tile.type === 'WARP') { showWarpModal(p, tile); isMoving = false; } else isMoving = false;
        }

        function checkAutoTurnEnd() {
            if (!autoTurnCheckbox.checked) return;
            if (players.every(p => p.hasMoved) && !isMoving && warpModal.style.display !== 'block') {
                setTimeout(() => { if (players.every(p => p.hasMoved)) endTurn(); }, 600);
            }
        }

        function showGameResult() {
            let stars = 0;
            if (killCount >= 3) stars++;
            if (turn <= 5) stars++;
            if (isBossDefeated) stars++;
            showMessage(`ğŸ‰ MISSION COMPLETE! (â˜…${stars}) ğŸ‰`, "#4caf50");
        }

        /**
         * í„´ ì¢…ë£Œ ì²˜ë¦¬ ë° ì êµ° AI ì‹¤í–‰ (ìˆœì°¨ ì´ë™ ì• ë‹ˆë©”ì´ì…˜ ì ìš©)
         */
        async function endTurn() {
            if (isMoving || warpModal.style.display === 'block' || isBossDefeated) return;
            isMoving = true;
            
            const activeEnemies = enemies.filter(e => e.alive && e.aggressive);

            for (let enemy of activeEnemies) {
                let bestMove = null;
                let minPathLen = Infinity;
                let targetPlayer = null;

                // 1. íƒ€ê²Ÿ ê²°ì •: ì§€í˜•ì ìœ¼ë¡œ ë„ë‹¬ ê°€ëŠ¥í•œ ì•„êµ° ì¤‘ ìµœë‹¨ ê±°ë¦¬ ëŒ€ìƒ ì„ ì •
                for (let p of players) {
                    let topoPath = getTopologyPath(enemy, p);
                    if (topoPath) {
                        if (topoPath.length < minPathLen) {
                            minPathLen = topoPath.length;
                            bestMove = topoPath[1]; // ë‹¤ìŒ ì´ë™í•  ì¹¸
                            targetPlayer = p;
                        }
                    }
                }

                // 2. ì´ë™ ì‹¤í–‰
                if (bestMove) {
                    const blockingEnemy = enemies.find(e => e.alive && e.q === bestMove.q && e.r === bestMove.r && e !== enemy);
                    
                    if (!blockingEnemy) {
                        enemy.q = bestMove.q;
                        enemy.r = bestMove.r;

                        if (enemy.q === targetPlayer.q && enemy.r === targetPlayer.r) {
                            addBattleAnimation(enemy.q, enemy.r);
                            enemy.alive = false; 
                            killCount++;
                            if (enemy.isBoss) { isBossDefeated = true; showGameResult(); }
                        }
                    }
                }
                
                await new Promise(r => setTimeout(r, 250)); // ì—°ì¶œ ëŒ€ê¸°
                if(isBossDefeated) break;
            }

            setTimeout(() => {
                if (isBossDefeated) return;
                turn++;
                players.forEach(p => p.hasMoved = false);
                isMoving = false;
                if (turn <= 5) showMessage(`TURN ${turn}`);
                else if (turn > 5) { showMessage("ì‘ì „ ì‹¤íŒ¨", "#f44336"); reset(); }
            }, 500);
        }

        function reset() {
            turn = 1; killCount = 0; isBossDefeated = false;
            players[0].q = 0; players[0].r = 0; players[1].q = -1; players[1].r = 2;
            players.forEach(p => p.hasMoved = false);
            enemies.forEach(e => { e.alive = true; e.q = e.initialQ; e.r = e.initialR; });
            activeAnimations = [];
            warpModal.style.display = 'none'; endTurnModal.style.display = 'none';
            showMessage(`TURN ${turn}`);
        }

        window.addEventListener('resize', initCanvas);
        window.onload = () => { initCanvas(); showMessage(`TURN ${turn}`); };
    </script>
</body>
</html>
